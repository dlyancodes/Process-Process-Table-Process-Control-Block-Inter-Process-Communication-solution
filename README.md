# Process-Process-Table-Process-Control-Block-Inter-Process-Communication-solution

Download Here: [Process – Process Table – Process Control Block – Inter Process Communication solution](https://jarviscodinghub.com/assignment/process-process-table-process-control-block-inter-process-communication-solution/)

For Custom/Original Work email jarviscodinghub@gmail.com/whatsapp +1(541)423-7793

In this exercise, you implement a new system call with signature: int getdpids(pid t top, pid t dpids[], int len); It finds process IDs (PIDs) of descendant processes of a given process, in breath first search order. The system call takes three arguments: the PID of the top process (top), a array to store the PIDs (dpids[]) and an integer that indicates the size of the array (len), in PIDs. Test your system call with the following programs (must be updated with your 1st name). Test program 1: #include #include #include #include #define LEN 14 /* buffer size, in PIDs (can’t be > 14) */ int main(int argc, char** args) { pid_t pid, cpid; /* PIDs */ pid_t dpids[LEN]; /* buffer for descendant PIDs */ int i, r; /* control vars */ printf(“Test 1 – Single child\n”); /* get the PID */ pid = getpid(); /* print the PID */ printf(“My PID is %d\n”, pid); cpid = fork(); if (cpid!=0) { /* in parent! */ printf(“Child PID is %d\n”, cpid); /* get and print all descendants */ r = michel_getdpids(pid, dpids, LEN); 1 printf(“Tree has %d process(es)\n”, r); for (i=0;i<r;i++) {=”” printf(“%d=”” “,=”” dpids[i]);=”” };=”” printf(“\n”);=”” }=”” else=”” *=”” in=”” child!=”” sleep(10);=”” sleep=”” 10=”” seconds=”” return=”” 0;=”” test=”” program=”” 2:=”” #include=”” <unistd.h=””> #include #include #include #include #define LEN 14 /* buffer size, in PIDs (can’t be > 14) */ #define N 5 /* number of forked children */ int main(int argc, char** args) { pid_t pid, cpid; /* PIDs */ pid_t dpids[LEN]; /* buffer for descendant PIDs */ int i, j, r; /* control vars */ printf(“Test 2 – Fan of children\n”); /* get the PID */ pid = getpid(); /* print the PID */ printf(“My PID is %d\n”, pid); /* fork N children */ for (j=0; j<n;j++) {=”” if=”” (fork()<=”0)” *=”” in=”” child!=”” break;=”” }=”” (pid=”=getpid())” root!=”” get=”” and=”” print=”” all=”” descendants=”” r=”michel_getdpids(pid,” dpids,=”” len);=”” printf(“tree=”” has=”” %d=”” process(es)\n”,=”” r);=”” for=”” (i=”0;i<r;i++)” printf(“%d=”” “,=”” (int)=”” dpids[i]);=”” };=”” printf(“\n”);=”” corroborate=”” using=”” “ps”=”” system(“ps=”” -o=”” pid,ppid,command”);=”” else=”” sleep(10);=”” sleep=”” 10=”” seconds=”” return=”” 0;=”” 2=”” test=”” program=”” 3:=”” #include=”” <unistd.h=””> #include #include #include #include #define LEN 14 /* buffer size, in PIDs (can’t be > 14) */ #define N 3 /* max number of forked children per parent */ int main(int argc, char** args) { pid_t pid, cpid; /* PIDs */ pid_t dpids[LEN]; /* buffer for descendant PIDs */ int i, r; /* control vars */ /* get the PID */ pid = getpid(); /* print the PID */ printf(“My PID is %d\n”, pid); printf(“Test 3 – Tree of children\n”); /* fork a tree of descendants */ for (i=0; i</n;j++)></r;i++)>

